# MCP（Model Context Protocol）概览
[官网](https://modelcontextprotocol.io/docs/getting-started/intro)
## 一、MCP 是什么

MCP（Model Context Protocol） 是一套用于 将外部能力以标准化方式暴露给大模型（LLM） 的协议。

它的核心目标是：

让大模型可以在受控、安全、可解释的前提下，调用外部系统的能力，而不是仅依赖自身上下文推理。

MCP 定义了：
- 大模型如何发现外部能力
- 如何理解这些能力能做什么
- 如何以结构化方式调用这些能力
- 如何接收结果并继续推理

## 二、MCP 解决了什么问题

在没有 MCP 之前，大模型存在明显边界：
- 无法直接访问数据库、文件系统、内部系统
- 无法调用企业已有服务
- 无法在受控条件下执行“动作”

MCP 通过“能力协议化”，解决了：
- 模型能力扩展问题
- 模型与外部系统解耦问题
- 工具调用的标准化问题

## 三、MCP 的核心组成

MCP 体系由三类角色构成：

1. MCP Host
- MCP Host 是 运行大模型的宿主环境
- 负责加载、配置和管理 MCP Server
- 将 MCP Server 的能力暴露给 LLM

示例：
- Claude Desktop
- 自建 LLM Agent Runtime

2. MCP Server
- MCP Server 是 能力提供方
- 每个 Server 通常只做一类事情（单一能力）
- 以 MCP 协议对外暴露工具（Tools）

示例能力：
- 查询数据库
- 搜索文档
- 访问内部 API
- 读写文件

3. LLM（大模型）
- LLM 是 能力的使用者和编排者
- 根据当前上下文，自主决定是否调用 MCP Server
- 决定调用顺序、参数与组合方式

MCP 中的编排逻辑不在代码里，而在模型推理中。

## 四、MCP 的工作流程

典型流程如下：
1.MCP Host 启动并加载 MCP Server
2.MCP Server 向 Host 声明自身能力（工具描述）
3.Host 将能力描述注入给 LLM
4.LLM 在推理过程中决定调用某个工具
5.MCP Server 执行并返回结果
6.LLM 基于结果继续推理或生成最终回答

## 五、MCP 与微服务的关系（重要澄清）

1. 可以类比，但不能等价

对比维度    Java 微服务    MCP
调用方    程序员编写的代码    大模型（LLM）
调用方式    显式、确定性    模型自主决策
接口设计    强类型、契约优先    语义优先、可理解
核心目标    业务拆分    能力扩展

2. 本质区别
- 微服务是 业务服务
- MCP Server 是 能力插件
- 微服务由代码编排
- MCP 由模型编排

更准确的表述是：

MCP 在架构形态上类似微服务，但本质上是面向大模型的能力暴露协议，而非业务服务架构。

## 六、如何理解 MCP Server

更贴切的类比包括：
- IDE 插件
- 数据库 Driver（JDBC）
- Kubernetes 插件（CSI / CNI）

即：

宿主（LLM）很强，但能力有限；MCP Server 以插件形式扩展其能力边界。

## 七、MCP 的设计特点
- 能力而非流程：只暴露“能做什么”，不定义“怎么做”
- 低状态或无状态：通常不维护复杂业务状态
- 语义友好：接口描述面向模型理解
- 高度解耦：模型与具体系统无直接依赖

## 八、典型使用场景
- 企业内部知识库问答
- 数据库 / 日志 / 报表查询
- DevOps 自动化操作
- 法律、金融、研发辅助 Agent
- 私有系统能力对接大模型

## 九、一句话总结

MCP 是一套让大模型“安全、标准化地调用外部能力”的协议体系。

它不是微服务替代品，而是：

面向 LLM 的能力扩展与治理基础设施。
